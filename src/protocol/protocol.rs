// this file is generated by prost-build, then manually tweaked to it can be
// more human-readable + added serde definitions for json serialization,
// renamed `pub` to `publication` due to reserve keyword, etc.

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct Error {
    #[prost(uint32, tag = "1")]
    pub code: u32,
    #[prost(string, tag = "2")]
    pub message: String,
    #[prost(bool, tag = "3")]
    pub temporary: bool,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct EmulationRequest {
    #[prost(string, tag = "1")]
    pub node: String,
    #[prost(string, tag = "2")]
    pub session: String,
    #[prost(bytes = "vec", tag = "3")]
    pub data: Vec<u8>,
}

/// Command sent from a client to a server.
/// ProtocolVersion2 uses id and one of the possible request messages.
#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct RawCommand {
    /// Id of command to let client match replies to commands.
    #[prost(uint32, tag = "1")]
    #[serde(skip_serializing_if = "super::is_default")]
    pub id: u32,
    /// ProtocolVersion2 client can send one of the following requests. Server will
    /// only take the first non-null request out of these and may return an error if
    /// client passed more than one request. We are not using oneof here due to JSON
    /// interoperability concerns.
    #[prost(message, optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub connect: Option<ConnectRequest>,
    #[prost(message, optional, tag = "5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscribe: Option<SubscribeRequest>,
    #[prost(message, optional, tag = "6")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unsubscribe: Option<UnsubscribeRequest>,
    #[prost(message, optional, tag = "7")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub publish: Option<PublishRequest>,
    #[prost(message, optional, tag = "8")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub presence: Option<PresenceRequest>,
    #[prost(message, optional, tag = "9")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub presence_stats: Option<PresenceStatsRequest>,
    #[prost(message, optional, tag = "10")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub history: Option<HistoryRequest>,
    #[prost(message, optional, tag = "11")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ping: Option<PingRequest>,
    #[prost(message, optional, tag = "12")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub send: Option<SendRequest>,
    #[prost(message, optional, tag = "13")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rpc: Option<RpcRequest>,
    #[prost(message, optional, tag = "14")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub refresh: Option<RefreshRequest>,
    #[prost(message, optional, tag = "15")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sub_refresh: Option<SubRefreshRequest>,
}

/// Reply sent from a server to a client.
/// ProtocolVersion2 uses id and one of the possible concrete result messages.
#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct RawReply {
    /// Id will only be set to a value > 0 for replies to commands. For pushes
    /// it will have zero value.
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Error can only be set in replies to commands. For pushes it will have zero value.
    #[prost(message, optional, tag = "2")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<Error>,
    /// ProtocolVersion2 server can send one of the following fields. We are not using
    /// oneof here due to JSON interoperability concerns.
    #[prost(message, optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub push: Option<RawPush>,
    #[prost(message, optional, tag = "5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub connect: Option<ConnectResult>,
    #[prost(message, optional, tag = "6")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscribe: Option<SubscribeResult>,
    #[prost(message, optional, tag = "7")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unsubscribe: Option<UnsubscribeResult>,
    #[prost(message, optional, tag = "8")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub publish: Option<PublishResult>,
    #[prost(message, optional, tag = "9")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub presence: Option<PresenceResult>,
    #[prost(message, optional, tag = "10")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub presence_stats: Option<PresenceStatsResult>,
    #[prost(message, optional, tag = "11")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub history: Option<HistoryResult>,
    #[prost(message, optional, tag = "12")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ping: Option<PingResult>,
    #[prost(message, optional, tag = "13")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rpc: Option<RpcResult>,
    #[prost(message, optional, tag = "14")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub refresh: Option<RefreshResult>,
    #[prost(message, optional, tag = "15")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sub_refresh: Option<SubRefreshResult>,
}

/// Push can be sent to a client as part of Reply in case of bidirectional transport or
/// without additional wrapping in case of unidirectional transports.
/// ProtocolVersion2 uses channel and one of the possible concrete push messages.
#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct RawPush {
    #[prost(string, tag = "2")]
    pub channel: String,
    /// ProtocolVersion2 server can push one of the following fields to the client. We are
    /// not using oneof here due to JSON interoperability concerns.
    #[prost(message, optional, tag = "4")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "pub")]
    pub publication: Option<Publication>,
    #[prost(message, optional, tag = "5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub join: Option<Join>,
    #[prost(message, optional, tag = "6")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub leave: Option<Leave>,
    #[prost(message, optional, tag = "7")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub unsubscribe: Option<Unsubscribe>,
    #[prost(message, optional, tag = "8")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<Message>,
    #[prost(message, optional, tag = "9")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub subscribe: Option<Subscribe>,
    #[prost(message, optional, tag = "10")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub connect: Option<Connect>,
    #[prost(message, optional, tag = "11")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub disconnect: Option<Disconnect>,
    #[prost(message, optional, tag = "12")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub refresh: Option<Refresh>,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct ClientInfo {
    #[prost(string, tag = "1")]
    pub user: String,
    #[prost(string, tag = "2")]
    pub client: String,
    #[prost(bytes = "vec", tag = "3")]
    pub conn_info: Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub chan_info: Vec<u8>,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct Publication {
    #[prost(bytes = "vec", tag = "4")]
    #[serde(deserialize_with = "super::deserialize_json")]
    pub data: Vec<u8>,
    #[prost(message, optional, tag = "5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub info: Option<ClientInfo>,
    #[prost(uint64, tag = "6")]
    pub offset: u64,
    #[prost(map = "string, string", tag = "7")]
    pub tags: std::collections::HashMap<String, String>,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct Join {
    #[prost(message, optional, tag = "1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub info: Option<ClientInfo>,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct Leave {
    #[prost(message, optional, tag = "1")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub info: Option<ClientInfo>,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct Unsubscribe {
    #[prost(uint32, tag = "2")]
    pub code: u32,
    #[prost(string, tag = "3")]
    pub reason: String,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct Subscribe {
    #[prost(bool, tag = "1")]
    pub recoverable: bool,
    #[prost(string, tag = "4")]
    pub epoch: String,
    #[prost(uint64, tag = "5")]
    pub offset: u64,
    #[prost(bool, tag = "6")]
    pub positioned: bool,
    #[prost(bytes = "vec", tag = "7")]
    pub data: Vec<u8>,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct Message {
    #[prost(bytes = "vec", tag = "1")]
    pub data: Vec<u8>,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct Connect {
    #[prost(string, tag = "1")]
    pub client: String,
    #[prost(string, tag = "2")]
    pub version: String,
    #[prost(bytes = "vec", tag = "3")]
    pub data: Vec<u8>,
    #[prost(map = "string, message", tag = "4")]
    pub subs: std::collections::HashMap<String, SubscribeResult>,
    #[prost(bool, tag = "5")]
    pub expires: bool,
    #[prost(uint32, tag = "6")]
    pub ttl: u32,
    #[prost(uint32, tag = "7")]
    pub ping: u32,
    #[prost(bool, tag = "8")]
    pub pong: bool,
    #[prost(string, tag = "9")]
    pub session: String,
    #[prost(string, tag = "10")]
    pub node: String,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct Disconnect {
    #[prost(uint32, tag = "1")]
    pub code: u32,
    #[prost(string, tag = "2")]
    pub reason: String,
    #[prost(bool, tag = "3")]
    pub reconnect: bool,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct Refresh {
    #[prost(bool, tag = "1")]
    pub expires: bool,
    #[prost(uint32, tag = "2")]
    pub ttl: u32,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct ConnectRequest {
    #[prost(string, tag = "1")]
    #[serde(skip_serializing_if = "String::is_empty")]
    pub token: String,
    #[prost(bytes = "vec", tag = "2")]
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub data: Vec<u8>,
    #[prost(map = "string, message", tag = "3")]
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub subs: std::collections::HashMap<String, SubscribeRequest>,
    #[prost(string, tag = "4")]
    #[serde(skip_serializing_if = "String::is_empty")]
    pub name: String,
    #[prost(string, tag = "5")]
    #[serde(skip_serializing_if = "String::is_empty")]
    pub version: String,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct ConnectResult {
    #[prost(string, tag = "1")]
    pub client: String,
    #[prost(string, tag = "2")]
    pub version: String,
    #[prost(bool, tag = "3")]
    pub expires: bool,
    #[prost(uint32, tag = "4")]
    pub ttl: u32,
    #[prost(bytes = "vec", tag = "5")]
    pub data: Vec<u8>,
    #[prost(map = "string, message", tag = "6")]
    pub subs: std::collections::HashMap<String, SubscribeResult>,
    #[prost(uint32, tag = "7")]
    pub ping: u32,
    #[prost(bool, tag = "8")]
    pub pong: bool,
    #[prost(string, tag = "9")]
    pub session: String,
    #[prost(string, tag = "10")]
    pub node: String,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct RefreshRequest {
    #[prost(string, tag = "1")]
    pub token: String,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct RefreshResult {
    #[prost(string, tag = "1")]
    pub client: String,
    #[prost(string, tag = "2")]
    pub version: String,
    #[prost(bool, tag = "3")]
    pub expires: bool,
    #[prost(uint32, tag = "4")]
    pub ttl: u32,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct SubscribeRequest {
    #[prost(string, tag = "1")]
    #[serde(skip_serializing_if = "String::is_empty")]
    pub channel: String,
    #[prost(string, tag = "2")]
    #[serde(skip_serializing_if = "String::is_empty")]
    pub token: String,
    #[prost(bool, tag = "3")]
    #[serde(skip_serializing_if = "super::is_default")]
    pub recover: bool,
    #[prost(string, tag = "6")]
    #[serde(skip_serializing_if = "String::is_empty")]
    pub epoch: String,
    #[prost(uint64, tag = "7")]
    #[serde(skip_serializing_if = "super::is_default")]
    pub offset: u64,
    #[prost(bytes = "vec", tag = "8")]
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub data: Vec<u8>,
    #[prost(bool, tag = "9")]
    #[serde(skip_serializing_if = "super::is_default")]
    pub positioned: bool,
    #[prost(bool, tag = "10")]
    #[serde(skip_serializing_if = "super::is_default")]
    pub recoverable: bool,
    #[prost(bool, tag = "11")]
    #[serde(skip_serializing_if = "super::is_default")]
    pub join_leave: bool,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct SubscribeResult {
    #[prost(bool, tag = "1")]
    pub expires: bool,
    #[prost(uint32, tag = "2")]
    pub ttl: u32,
    #[prost(bool, tag = "3")]
    pub recoverable: bool,
    #[prost(string, tag = "6")]
    pub epoch: String,
    #[prost(message, repeated, tag = "7")]
    pub publications: Vec<Publication>,
    #[prost(bool, tag = "8")]
    pub recovered: bool,
    #[prost(uint64, tag = "9")]
    pub offset: u64,
    #[prost(bool, tag = "10")]
    pub positioned: bool,
    #[prost(bytes = "vec", tag = "11")]
    pub data: Vec<u8>,
    #[prost(bool, tag = "12")]
    pub was_recovering: bool,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct SubRefreshRequest {
    #[prost(string, tag = "1")]
    pub channel: String,
    #[prost(string, tag = "2")]
    pub token: String,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct SubRefreshResult {
    #[prost(bool, tag = "1")]
    pub expires: bool,
    #[prost(uint32, tag = "2")]
    pub ttl: u32,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct UnsubscribeRequest {
    #[prost(string, tag = "1")]
    #[serde(skip_serializing_if = "String::is_empty")]
    pub channel: String,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct UnsubscribeResult {}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct PublishRequest {
    #[prost(string, tag = "1")]
    pub channel: String,
    #[prost(bytes = "vec", tag = "2")]
    #[serde(serialize_with = "super::serialize_json")]
    pub data: Vec<u8>,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct PublishResult {}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct PresenceRequest {
    #[prost(string, tag = "1")]
    pub channel: String,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct PresenceResult {
    #[prost(map = "string, message", tag = "1")]
    pub presence: std::collections::HashMap<String, ClientInfo>,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct PresenceStatsRequest {
    #[prost(string, tag = "1")]
    pub channel: String,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct PresenceStatsResult {
    #[prost(uint32, tag = "1")]
    pub num_clients: u32,
    #[prost(uint32, tag = "2")]
    pub num_users: u32,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct StreamPosition {
    #[prost(uint64, tag = "1")]
    pub offset: u64,
    #[prost(string, tag = "2")]
    pub epoch: String,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct HistoryRequest {
    #[prost(string, tag = "1")]
    pub channel: String,
    #[prost(int32, tag = "7")]
    pub limit: i32,
    #[prost(message, optional, tag = "8")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub since: Option<StreamPosition>,
    #[prost(bool, tag = "9")]
    pub reverse: bool,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct HistoryResult {
    #[prost(message, repeated, tag = "1")]
    pub publications: Vec<Publication>,
    #[prost(string, tag = "2")]
    pub epoch: String,
    #[prost(uint64, tag = "3")]
    pub offset: u64,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct PingRequest {}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct PingResult {}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct RpcRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub data: Vec<u8>,
    #[prost(string, tag = "2")]
    pub method: String,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct RpcResult {
    #[prost(bytes = "vec", tag = "1")]
    pub data: Vec<u8>,
}

#[derive(serde::Serialize, serde::Deserialize, prost::Message, Clone, PartialEq)]
#[serde(default, rename_all = "camelCase")]
pub struct SendRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub data: Vec<u8>,
}
